% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spatialCorrelation.R
\name{spatialCorrelationGeneExp}
\alias{spatialCorrelationGeneExp}
\title{spatialCorrelationGeneExp}
\usage{
spatialCorrelationGeneExp(
  input,
  nPermutations = 100,
  deltaX = NULL,
  deltaY = NULL,
  maxDistPrctile = 0.25,
  returnPermutations = FALSE,
  assayName = NULL,
  nThreads = 1,
  BPPARAM = NULL,
  verbose = TRUE
)
}
\arguments{
\item{input}{\code{list} List of two SpatialExperiment objects with matched
spatial locations. The first element corresponds to the first
SpatialExperiment (`X`), and the second to the second SpatialExperiment
(`Y`). The SpatialCoords of the two SpatialExperiment objects should be on
the same coordinate framework and observations at the same coordinate
location in both datasets should have the same row names. If the
SpatialExperiment objects do not have shared locations, use
`SEraster::rasterizeGeneExpression()` to generate SpatialExperiment objects
with shared pixel locations. See \code{assayName} parameter if the
SpatialExperiment objects have more than one assay.}

\item{nPermutations}{\code{integer} or \code{double}: number of permutations
to generate to build the empirical null distribution. This number will
determine the precision of the p-value. Default is \code{100}, such that
the smallest p-value is 0.01}

\item{deltaX}{\code{list}: List of single numerics or list of numeric vectors
to use for delta, the parameter controlling the degree of smoothing in
permutations of X. The length of the list should the same as the number of
rows in the SpatialExperiment.  Delta is a proportion calculated by
dividing k neighbors by N total observations (columns) in X, where k is the
number of neighbors in the permutation of X that should be within the
radius smoothed by the Gaussian kernel to achieve the amount of
autocorrelation present in the original X. If a single delta is not known,
a sequence of deltas can be inputted and the best delta will be found such
that it minimizes the sum of squares of the residuals between the variogram
of the permutation generated from the delta and the variogram of the
target. Default is \code{NULL}. If no value is supplied for \code{deltaX},
\code{seq(0.1,0.9,0.1)}, the sequence of every 0.1 from 0.1 to 0.9, will be
used to find the best delta for each row (gene) in X.}

\item{deltaY}{\code{list}: List of single numerics or list of numeric vectors
to use for delta, the parameter controlling the degree of smoothing in
permutations of Y. \code{deltaY} is like \code{deltaX} but for permuting
data in Y instead of X. Default is \code{NULL}. If no value is supplied for
\code{deltaY}, \code{seq(0.1,0.9,0.1)}, the sequence of every 0.1 from 0.1
to 0.9, will be used to find the best delta for permutations for each row
(gene) in Y.}

\item{maxDistPrctile}{\code{numeric}: percentile of distances between pixels
to use as max distance in when calculating variograms. Default = 0.25. At
greater distances the variogram is less precise because there are fewer
pairs of points with that distance between them. Therefore, since the goal
is to minimize the difference between the variogram of X and those of its
permutations, the variogram should be subsetted to the percentile that is
more robust.}

\item{returnPermutations}{\code{logical}: indicate whether the dataframe
returned as output will have a column with the values of the permutations
used to calculate the null correlations and the empirical p-value. Default
is \code{FALSE}}

\item{assayName}{\code{character} or \code{integer} A character string or
numeric specifying the assay in the SpatialExperiment to use. Default is
\code{NULL}. If no value is supplied for \code{assayName}, then the first
assay is used as a default}

\item{nThreads}{\code{integer}: Number of threads for parallelization.
Default = 1. Inputting this argument when the \code{BPPARAM} argument is
\code{NULL} would set parallel execution back-end to be
\code{BiocParallel::MulticoreParam(workers = nThreads)}. We recommend
setting this argument to be the number of cores available
(\code{parallel::detectCores(logical = FALSE)}). If \code{BPPARAM} argument
is not \code{NULL}, the \code{BPPARAM} argument would override
\code{nThreads} argument.}

\item{BPPARAM}{\code{BiocParallelParam}: Optional additional argument for
parallelization. This argument is provided for advanced users of
\code{BiocParallel} for further flexibility for setting up
parallel-execution back-end. Default is NULL. If provided, this is assumed
to be an instance of \code{BiocParallelParam}.}

\item{verbose}{\code{logical}: indicate whether to print row number and name
to show progress as the function iterates through the rows of the
SpatialExperiments to calculate a correlation coefficient and empirical
p-value for each row}
}
\value{
The output is returned as a \code{data.frame}. The rownames are the
  rownames of the SpatialExperiments. The names of the columns and their
  contents are as follows:
\itemize{
  \item{\code{correlationCoef}}{Pearson's correlation coefficient.}
  \item{\code{pValueNaive}}{the analytical p-value naively assuming independent
  observations}
  \item{\code{pValuePermuteX}}{the p-value when creating an empirical null from permutations
  of observations in X}
  \item{\code{pValuePermuteY}}{the p-value when creating an empirical null from
  permutations of observations in Y}
  \item{\code{deltaStarMedianX}}{the median delta star (the delta which
  minimizes the difference between the variogram of the permutation and the
  variogram of observations) across permutations of X}
  \item{\code{deltaStarMedianY}}{the median delta star across permutations of Y}
  \item{\code{deltaStarX}}{list of delta star for all permutations of X}
  \item{\code{deltaStarY}}{list of delta star for all permutations of Y}
  \item{\code{nullCorrelationsX}}{correlation coefficients for Y and all permuations of X}
  \item{\code{nullCorrelationsY}}{correlation coefficients for X and all permuations of Y}
  }
}
\description{
Function to calculate Pearson's correlation between assays from
  two SpatialExperiment datasets. To replace the analytical p-value which
  results in a high false positive rate for autocorrelated spatial patterns,
  it calculates empirical p-values from empirical null distributions
  generated from permuting the datasets and then smoothing to maintain the
  original degree of autocorrelation
}
\examples{

data(quakes)

##### Rasterize to get pixels at matched spatial locations #####
rastKidney <- SEraster::rasterizeGeneExpression(speKidney, assay_name = 'counts', resolution = 0.2, fun = "mean",BPPARAM = BiocParallel::MulticoreParam(), square = FALSE)

cor <- spatialCorrelation(X = quakes_data$depth,
                          Y = quakes_data$mag,
                          pos = cbind(quakes_data$lat, quakes_data$long))
cor

#plot the delta star (the delta which minimizes the difference between the
variogram of the permutation and the variogram of observations) for all
permutations to see if clear peak found in the range inputted
hist(cor$deltaStarX[[1]])
hist(cor$deltaStarY[[1]])

#plot null distribution of correlations to see if normally distributed
hist(cor$nullCorrelationsX[[1]])
hist(cor$nullCorrelationsY[[1]])

#example of inputting specific range for deltaX and deltaY
cor2 <- spatialCorrelation(X = quakes_data$depth,
                          Y = quakes_data$mag,
                          pos = cbind(quakes_data$lat, quakes_data$long),
                          deltaX = seq(0.05, 0.9, 0.05),
                          deltaY = seq(0.02, 0.5, 0.02))

cor2

hist(cor2$deltaStarX[[1]])
hist(cor2$deltaStarY[[1]])
hist(cor2$nullCorrelationsX[[1]])
hist(cor2$nullCorrelationsY[[1]])

#visualizations of the spatial data to verify negative correlation
library(ggplot2)
p1 <- ggplot2::ggplot(quakes_data, ggplot2::aes(x = long, y = lat, color = depth)) +
ggplot2::geom_point(size = 2) + # Add points for each earthquake
  ggplot2::scale_color_gradient(low = "lightblue", high = "blue") + # Color gradient for depth
  ggplot2::labs(title = "Locations of Earthquakes off Fiji", x = "Longitude", y = "Latitude", color = "Depth (km)") +
  ggplot2::theme_minimal() + # Apply a minimal theme
  ggplot2::coord_map() # Use a map projection for better representation of the globe

p2 <- ggplot2::ggplot(quakes_data, ggplot2::aes(x = long, y = lat, color = mag)) +
ggplot2::geom_point(size = 2) + # Add points for each earthquake
  ggplot2::scale_color_gradient(low = "lightblue", high = "blue") + # Color gradient for mag
  ggplot2::labs(title = "Locations of Earthquakes off Fiji", x = "Longitude", y = "Latitude", color = "Richter Magnitude") +
  ggplot2::theme_minimal() + # Apply a minimal theme
  ggplot2::coord_map() # Use a map projection for better representation of the globe

p1
p2
}
